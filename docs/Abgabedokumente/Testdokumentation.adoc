= Test Cases: {project-name}
Til Guhlmann <til.guhlmann@stud.htw-dresden.de>; Enna Scheer <enna.scheer@stud.htw-dresden.de>; Emujin Uuganbayar <emujin.uuganbayar@stud.htw-dresden.de>; Erik Vogt <erik.vogt@stud.htw-dresden.de>; Justus Müller <justus.mueller@stud.htw-dresden.de>; Mark Schrader <smark.schrader@stud.htw-dresden.de>; Khanh Ly La <khanhly.la@stud.htw-dresden.de>
{localdatetime} 
include::../_includes/default-attributes.inc.adoc[]
// Platzhalter für weitere Dokumenten-Attribute

== Zweck und Ziel
Dieses Dokument beschreibt die getesteten Module und Komponenten der Anwendung {project-name}. Es dient als Referenz für das Testteam und andere Stakeholder, um einen Überblick über die durchgeführten Tests und deren Ergebnisse zu erhalten. Ziel ist es, die Qualität und Zuverlässigkeit der Software sicherzustellen, indem alle kritischen Funktionen und Komponenten gründlich getestet werden.

== Testkonzept und Architektur
Das Testkonzept umfasst fünf Haupttestarten: Unit Tests, Integrationstests, Datenbanktests und End-to-End (E2E) Tests sowie Abnahmetests. Jede Testart hat eine spezifische Architektur und einen definierten Zweck innerhalb des Testprozesses. Manuelle Tests werden nicht explizit in diesem Dokument behandelt, da der Fokus auf automatisierten Tests liegt. Dennoch können manuelle Tests ergänzend eingesetzt werden, um spezifische Szenarien zu überprüfen, die möglicherweise nicht durch automatisierte Tests abgedeckt sind.

*Unit Tests Ebene:*

In dieser Ebene werden Tests in isolierten Umgebungen durchgeführt. Sie testen einzelne Funktionen der Module unabhängig voneinander. Es wird zwischen Frontend und Backend Unit Tests unterschieden.

- *Frontend Unit Tests:* Testen Vue-Komponenten und Composables in Isolation mit vitest und @vue/test-utils. Mock-Daten werden verwendet, um Abhängigkeiten vom Backend zu eliminieren.

- *Backend Unit Tests:* Testen einzelne API-Funktionen und Geschäftslogik isoliert. Mock-Daten ersetzen Datenbankzugriffe und externe Abhängigkeiten.

*Integrations Ebene (Whitebox-Tests):*

Auf dieser Ebene werden mehrere Module integriert getestet, um deren Zusammenspiel und interne Funktionsweise zu prüfen. Eine Test-PostgreSQL-Datenbank wird mittels Docker-Container bereitgestellt. Die Tests haben direkten Zugriff auf die interne Datenschicht (Prisma ORM) und überprüfen Geschäftslogik, API-Funktionalität und Datenbankinteraktionen gemeinsam.

*Datenbanktests Ebene:*

Datenbanktests werden mit pgTab und PostgreSQL durchgeführt, um die Integrität und Korrektheit der Datenbankstruktur zu überprüfen. Die Tests validieren Tabellenstrukturen, Constraints, Foreign Key Beziehungen und Migrationen. Sie stellen sicher, dass die vom Prisma ORM generierten Datenbankschemas den erwarteten Spezifikationen entsprechen.

*System Tests (E2E):*

System Tests überprüfen wichtige End-to-End-Workflows vom Frontend der Anwendung und stellen sicher, dass Frontend und Backend nahtlos zusammenarbeiten. Das Frontend wird mittels automatisierter Klickroutinen (Playwright) getestet. Diese Tests laufen in einer vollständigen Anwendungsumgebung (Frontend + Backend), ohne das Backend zu mocken, um eine realistische Testumgebung zu gewährleisten.


*Testarten Übersicht:*


.Testpyramide der Teststrategie
image::Testpyramide.png[Testpyramide, width=600]

[cols="2,3", options="header"]
|===
| Testart | Verwendete Frameworks / Tools

| Unit Test Frontend
| vitest, @vue/test-utils, happy-dom

| Unit Test Backend
| vitest

| Integration Test (Backend)
| vitest, Prisma, PostgreSQL, Docker, dotenv

| E2E Test
| Playwright

| DB Tests
| pgTab 
|===

== Testdokumentation und Berichterstattung

Es erfolgt eine manuelle Dokumentation der Tests in den jeweiligen Task-Tickets in GitHub. Dort werden die durchgeführten Tests, deren Ergebnisse und eventuelle Abweichungen festgehalten. Tests werden priorisiert nach kritischen Funktionen durchgeführt, um sicherzustellen, dass die wichtigsten Anwendungsbereiche fehlerfrei funktionieren. Anschließend werden weitere Tests für weniger kritische Funktionen durchgeführt, um eine umfassende Testabdeckung zu gewährleisten. Es wird sich an die Vorgaben der Akzeptanzkriterien gehalten, um die Anforderungen der User Stories zu erfüllen. Wenn ein Test erfolgreich war, kann das entsprechende Akzeptanzkriterium als erfüllt markiert und das Ticket geschlossen werden. Bei einem fehlgeschlagenen Test wird das Ticket mit den Fehlerdetails aktualisiert und als Bug gekennzeichnet, um Nachverfolgung und Behebung zu ermöglichen.

== Getestete Komponenten

=== Frontend Unit Tests

Pfad: src/nuxt-finanztracker_/test/unit/Frontend

Geprüft wurden:

.Ausgaben
[cols="2,3", options="header"]
|===
| Prüfpunkt | Testdatei
| Ausgaben Modul anzeigen | `test/unit/frontend/Test_ausgabe/Kontobewegung.expense.category.select.spec.ts`
| Ausgabenerfassung abbrechen | `test/unit/frontend/Test_ausgabe/Kontobewegung.expense.popup.cancel.spec.ts`
|===

.Darkmode
[cols="2,3", options="header"]
|===
| Prüfpunkt | Testdatei
| Wechsel zwischen Hell- und Dunkelmodus (beide Richtungen) | `test/unit/frontend/Test_darkmode/DarkMode.spec.ts`
|===

.Dauerauftrag
[cols="2,3", options="header"]
|===
| Prüfpunkt | Testdatei
| Bestätigungs-Popup zum Löschen eines Dauerauftrags | `test/unit/frontend/Test_dauerauftrag/Kontobewegung.dauerauftrag.popup.delete.spec.ts`
| Bearbeiten-Popup eines Dauerauftrags | `test/unit/frontend/Test_dauerauftrag/Kontobewegung.dauerauftrag.popup.edit.spec.ts`
| Öffnen des Dauerauftrag-Verwaltungsmodals | `test/unit/frontend/Test_dauerauftrag/Kontobewegung.dauerauftrag.popup.open.spec.ts`
|===

.Einnahmen
[cols="2,3", options="header"]
|===
| Prüfpunkt | Testdatei
| Einnahme Popup abbrechen | `test/unit/frontend/Test_einnahme/Kontobewegung.income.popup.cancel.spec.ts`
| Einnahme Kategorie anzeigen | `test/unit/frontend/Test_einnahme/Kontobewegung.incomes.category.select.spec.ts`
|===

.Export
[cols="2,3", options="header"]
|===
| Prüfpunkt | Testdatei
| Default Export Auswahl | `test/unit/frontend/Test_export/Export.default.selection.spec.ts`
| Dateiname Eingabe | `test/unit/frontend/Test_export/Export.filename.input.spec.ts`
| Eingrenzung des Datumsbereichs | `test/unit/frontend/Test_export/Export.no.data.selected.spec.ts`
|===

.Kategorien
[cols="2,3", options="header"]
|===
| Prüfpunkt | Testdatei
| Kategorie erstellen | `test/unit/frontend/Test_Kategorie/categoryManager.Category.create.spec.ts`
| Kategorie Popup öffnen | `test/unit/frontend/Test_Kategorie/categoryManager.Category.popup.open.spec.ts`
|===

.Kontobewegungstabelle
[cols="2,3", options="header"]
|===
| Prüfpunkt | Testdatei
| Einnahme löschen Popup anzeigen | `test/unit/frontend/Test_kontobewegungstabelle/Kontobewegung.income.popup.delete.spec.ts`
| Ausgabe löschen Popup anzeigen | `test/unit/frontend/Test_kontobewegungstabelle/Kontobewegung.expense.popup.delete.spec.ts`
| Kontobewegung Tabelle Anzeige, Suche, Bearbeitung, Löschung | `test/unit/frontend/Test_kontobewegungstabelle/Kontobewegung.table.render.spec.ts`
|===


=== Backend Unit Tests

Pfad: src/nuxt-finanztracker_/test/unit/Backend

Geprüft wurden:

[cols="2,3", options="header"]
|===
| Prüfpunkt | Testdatei
| Kategorien-API Endpunkte (Abrufen, Erstellen, Aktualisieren, Löschen) | `test/unit/backend/category.service.spec.ts`
| Einnahme und Ausgabe API-Funktionen | `test/unit/backend/getAllTransactions.spec.ts`, `test/unit/backend/diff.income.expenses.spec.ts`
| Validierung von Eingabeparametern | `test/unit/backend/refreshbugetafterinput.spec.ts`
| Error-Handling und Exception-Management | Integriert in einzelnen Test-Dateien
|===

=== Integration Tests

Pfad: src/nuxt-finanztracker_/test/integration/

Geprüft wurden:

[cols="1, 2", options="header"]
|===
| Prüfpunkt | Testdatei
| Kategorien: Erstellung, Abrufen, Aktualisierung in Datenbank | `test/integration/backend/category.create.spec.ts`, `test/integration/backend/category.newcategoryinlist.spec.ts`
| Kategorien Performance-Test mit realen Datenbankabfragen | `test/integration/backend/category.performance.spec.ts`
| Kategorie-Farb-Eigenschaft und deren Persistierung | `test/integration/backend/category.color.spec.ts`
| Einnahmen: Erstellung, Speicherung, Abrufen aus Datenbank | `test/integration/backend/transaction.income.delete.spec.ts`
| Ausgaben: Erstellung, Speicherung, Abrufen aus Datenbank | `test/integration/backend/transaction.expense.delete.spec.ts`
| Datenbankzustand nach Transaktionen validieren | In allen Integrationstests implementiert
|===


=== System Tests (E2E)

Pfad: src/nuxt-finanztracker_/test/e2e/

Geprüft wurden:

[cols="3, 2", options="header"]
|===
| Prüfpunkt | Testdatei
| User-Authentifizierung (funktion Login) | `test/e2e/index/index.spec.ts`
| Challange: Buttons vorhanden | `test/e2e/challenge/challenge.spec.ts`
| Reiter-Navigation | `test/e2e/index/index.spec.ts`
| Dashboard: Kontostand vorhanden, Diagramm-Überschrift einsehbar, manueller Zeitraum ansprechbar | `test/e2e/dashboard/dashboard.spec.ts`
| Kontobewegung: Einnahme- und Ausgabenerfassung, Dauerauftrag und Kategorie-Verwalten Modal vorhanden | `test/e2e/kontobewegung/kontobewegung.spec.ts`
| Export: Überschrift vorhanden | `test/e2e/export/export.spec.ts`
|===


=== Datenbanktests

Datenbankschema und -struktur: src/nuxt-finanztracker_/prisma/schema.prisma
Supabase Database Tests: src/nuxt-finanztracker_/supabase/tests/database/

Geprüft wurden:

[cols="3,2", options="header"]
|===
| Prüfpunkt | Testdatei
| Existieren die geforderten Tabellen | `supabase/tests/database/00_table_test.sql`
| Ist Row-Level-Security aktiviert | `supabase/tests/database/01_rls_test.sql`
| Kann ein Testuser erstellt werden | `supabase/tests/database/00_table_test.sql`, `supabase/tests/database/01_rls_test.sql`
| Kann der Testuser ein Budget, Goal, Einnahme, Ausgabe oder Kategorie erstellen | `supabase/tests/database/02_budget_test.sql`, `supabase/tests/database/03_goals_test.sql`, `supabase/tests/database/04_categories_test.sql`, `supabase/tests/database/05_incomes_test.sql`, `supabase/tests/database/06_expenses_test.sql`
| Kann ein Testuser 2 die erstellten Daten von Testuser1 sehen(Row-Level-Security) | `supabase/tests/database/07_budget_security_test.sql`, `supabase/tests/database/08_goals_security_test.sql`, `supabase/tests/database/09_categories_security_test.sql`, `supabase/tests/database/10_incomes_security_test.sql`, `supabase/tests/database/11_expenses_security_test.sql`
|===

=== Abnahmetests
Abnahmetests werden nicht explizit in diesem Dokument behandelt, da der Fokus auf automatisierten Tests liegt. 

Eine Abnahme erfolgt durch den Produkt-Owner nach erfolgreichem Bestehen der automatisierten Tests und der Erfüllung der Akzeptanzkriterien für die jeweiligen User Stories.

== GitHub Actions
Die Testarten sind in die CI/CD-Pipeline von GitHub Actions integriert. Bei Pull-Request in den Main Branch werden die Tests automatisch ausgeführt, um sicherzustellen, dass neue Änderungen keine bestehenden Funktionen beeinträchtigen.

Tabelle der GitHub Actions Workflows:
[cols="3,4", options="header"]
|===
| Workflow Name | Beschreibung
| Tests | Führt Unit Tests (Frontend und Backend) sowie Integration Tests aus, um die Codequalität einzelner Module und deren Zusammenspiel sicherzustellen.
| E2E/Playwright | Führt System Tests (End-to-End) mit Playwright aus, um wichtige Workflows in der vollständigen Anwendung zu überprüfen.
| Database Tests | Validiert die Datenbankstruktur und Constraints mit pgTab und PostgreSQL.
| Supabase Deployment | Automatisiert die Bereitstellung der Anwendung auf Supabase nach erfolgreichem Bestehen aller Tests.
|===

== Lokales Testen der Anwendung
Um die Anwendung lokal zu testen, führe die Schritte in der README.md Datei im folgenden Pfad aus: 
src/nuxt-finanztracker_/test/README.md

== Probleme

Zu spätes beginnen der Tests:
Da die Tests erst relativ spät im Projekt begonnen wurden, konnten nicht alle Komponenten und Funktionen der Anwendung getestet werden. Dies führte zu einer unvollständigen Testabdeckung und möglicherweise unentdeckten Fehlern in nicht getesteten Bereichen.

Testdriven Development (TDD) wurde nicht angewendet:
Die Tests wurden nach der Implementierung der Funktionen geschrieben, anstatt vorab. Dies erschwerte die Identifikation von Fehlern während der Entwicklungsphase und führte zu einer reaktiven statt proaktiven Teststrategie.